
#' Initialize \code{wdraws} object for tracking MCMC draws of the spatial weight matrix
#'
#' @param W_prior Priors for the spatial weight matrix, generated by \code{\link{W_priors}}
#' @param rho The value of the spatial autoregressive parameter. If \code{NULL} (default) then no log determinants are generated.
#'
#' @return An object of class \code{wdraws}
#' @export
init_sampler_W = function(W_prior,
                          rho = NULL) {
  n = nrow(W_prior$W_prior)
  curr.W <- matrix(0, n, n) # not standardized W
  ### generate curr.W from the prior distribution
  if (W_prior$symmetric_prior) {
    ii_samples <- sample(2:n, n - 1, replace = F)
  } else {
    ii_samples <- sample(1:n, n, replace = F)
  }
  for (i in ii_samples) {
    if (W_prior$symmetric_prior) {
      jj_samples <- sample(c(1:(i - 1)), i - 1, replace = F)
    } else {
      jj_samples <- sample(1:n, n, replace = F)
    }
    for (j in jj_samples) {
      curr.Wpr <- W_prior$W_prior[i, j]
      if (W_prior$symmetric_prior) {
        neighb1 <- sum((curr.W + t(curr.W))[i, ])
      } else {
        neighb1 <- sum(curr.W[i, ])
      }
      if (W_prior$use_reject_prior) {
        if (W_prior$symmetric_prior) {
          rjct_n <- max(neighb1, sum((curr.W + t(curr.W))[j, ]))
        } else {
          rjct_n <- neighb1
        }
        if (rjct_n < W_prior$min_neighbors) {
          curr.Wpr <- 1
        } else if (rjct_n == W_prior$max_neighbors) {
          curr.Wpr <- 0
        }
      }
      if (W_prior$use_bbinom_prior) {
        bbprior1 <- bbinompdf(neighb1, n - 1, W_prior$bbinom_a_prior, W_prior$bbinom_b_prior) * curr.Wpr
        bbprior0 <- (1 - bbinompdf(neighb1, n - 1, W_prior$bbinom_a_prior, W_prior$bbinom_b_prior)) * (1 - curr.Wpr)
        bbprior_ <- bbprior1 / (bbprior1 + bbprior0)
      } else {
        bbprior_ <- curr.Wpr
      }
      prob.delta <- bbprior_ / (bbprior_ + (1 - bbprior_))
      if (prob.delta == 1) {
        curr.W[i, j] <- 1
      } else if (prob.delta != 0) {
        curr.W[i, j] <- stats::rbinom(1, 1, prob.delta)
      }
    }
  }
  if (W_prior$symmetric_prior) {
    curr.W[upper.tri(curr.W, diag = TRUE)] <- 0
  }
  curr.w <- matrix(0, n, n)
  if (W_prior$row_standardized_prior) {
    if (W_prior$symmetric_prior) {
      curr.w <- (curr.W + t(curr.W)) / rowSums((curr.W + t(curr.W)))
    } else {
      curr.w <- curr.W / rowSums(curr.W)
    }
    curr.w[is.na(curr.w)] <- 0
  } else {
    if (W_prior$symmetric_prior) {
      curr.w <- curr.W + t(curr.W)
    } else {
      curr.w <- curr.W
    }
  }
  if (is.null(rho)) {
    curr.A = curr.AI = curr.logdet = NULL
  } else {
    curr.A <- Matrix::.sparseDiagonal(n) - rho * curr.w
    curr.AI <- as.matrix(solve(curr.A))
    curr.logdet <- log(Matrix::det(curr.A))
  }
  ret = list(curr.w = curr.w,curr.W = curr.W,
              curr.logdet = curr.logdet,curr.A = curr.A,curr.AI = curr.AI)
  class(ret) = "wdraws"
  return(ret)
}


#' Sample \eqn{W} based on the current state of t
#'
#' @param tY An \eqn{n x tt} matrix of dependent variables
#' @param curr.txb An \eqn{n x tt} matrix of means
#' @param curr.sigma The variance parameter
#' @param W_prior Priors for the spatial weight matrix, generated by \code{\link{W_priors}}
#' @param wdraws An object of class \code{wdraws}
#' @param curr.rho The value of the spatial autoregressive parameter. If \code{NULL} (default) then no log determinants are generated.
#'
#' @return An object of class \code{wdraws}
#' @export
sample_W = function(tY,curr.txb,curr.sigma,W_prior,wdraws,curr.rho = NULL) {
  n = nrow(tY)
  tt = ncol(tY)
  curr.W = wdraws$curr.W
  curr.w = wdraws$curr.w
  curr.A = wdraws$curr.A
  curr.AI = wdraws$curr.AI
  curr.logdet = wdraws$curr.logdet

  if (W_prior$symmetric_prior) {
    ii_samples <- sample(2:n, n - 1, replace = F)
  } else {
    ii_samples <- sample(1:n, n, replace = F)
  }
  for (ii in ii_samples) {
    if (W_prior$symmetric_prior) {
      jj_samples <- sample(c(1:(ii - 1)), ii - 1, replace = F)
    } else {
      jj_samples <- sample(1:n, n, replace = F)
    }
    for (jj in jj_samples) {
      if (W_prior$W_prior[ii, jj] == 0) {
        curr.W[ii, jj] <- 0
      } else if (W_prior$W_prior[ii, jj] == 1) {
        curr.W[ii, jj] <- 1
      } else {
        if (W_prior$symmetric_prior) {
          ch_elmnt <- c(ii, jj)
        } else {
          ch_elmnt <- ii
        }
        W0 <- W1 <- curr.W
        was1 <- (curr.W[ii, jj] == 1)
        if (was1) {
          W0[ii, jj] <- 0
          if (W_prior$symmetric_prior) {
            WW0 <- (W0 + t(W0))
          } else {
            WW0 <- W0
          }
          w0 <- w1 <- curr.w
          if (W_prior$row_standardized_prior) {
            w0[ch_elmnt, ] <- WW0[ch_elmnt, ] / rowSums(WW0[ch_elmnt, , drop = F])
          } else {
            w0[ch_elmnt, ] <- WW0[ch_elmnt, ]
          }
          w0[is.na(w0)] <- 0
          A0 <- diag(n) - curr.rho * w0
          A1 <- curr.A
          diff0 <- A0[ch_elmnt, , drop = F] - curr.A[ch_elmnt, , drop = F]
          res0 <- update_ldetAI(ch_elmnt, diff0, curr.AI, curr.logdet)
          logdet0 <- res0$logdet
          logdet1 <- curr.logdet
        } else {
          W1[ii, jj] <- 1
          if (W_prior$symmetric_prior) {
            WW1 <- (W1 + t(W1))
          } else {
            WW1 <- W1
          }
          w0 <- w1 <- curr.w
          if (W_prior$row_standardized_prior) {
            w1[ch_elmnt, ] <- WW1[ch_elmnt, ] / rowSums(WW1[ch_elmnt, , drop = F])
          } else {
            w1[ch_elmnt, ] <- WW1[ch_elmnt, ]
          }
          w1[is.na(w1)] <- 0
          A1 <- diag(n) - curr.rho * w1
          A0 <- curr.A
          diff1 <- A1[ch_elmnt, , drop = F] - curr.A[ch_elmnt, , drop = F]
          logdet0 <- curr.logdet
          res1 <- update_ldetAI(ch_elmnt, diff1, curr.AI, curr.logdet)
          logdet1 <- res1$logdet
        }

        curr.W_prior <- W_prior$W_prior
        # # rejection prior
        if (W_prior$use_reject_prior) {
          if (W_prior$symmetric_prior) {
            W_reject1 <- rowSums(w1[c(ii, jj), ] > 0) > W_prior$max_neighbors
          } else {
            W_reject1 <- sum(W1[ii, ]) > W_prior$max_neighbors
          }
          if (sum(W_reject1) > 0) {
            curr.W_prior[ii, jj] <- 0
          }
          if (W_prior$symmetric_prior) {
            W_reject0 <- rowSums(w0[c(ii, jj), ] > 0) < W_prior$min_neighbors
          } else {
            W_reject0 <- sum(W0[ii, ]) < W_prior$min_neighbors
          }
          if (sum(W_reject0) > 0) {
            curr.W_prior[ii, jj] <- 1
          }
        }
        if (W_prior$use_bbinom_prior) {
          if (W_prior$symmetric_prior) {
            neighb0 <- sum((W0 + t(W0))[ii, ])
          } else {
            neighb0 <- sum(W0[ii, ])
          }
          # bbprior0 = bbinompdf(neighb0,n-1,bbinom_a_prior,bbinom_b_prior) * (1 - curr.W_prior[ii,jj])
          bbprior0 <- bbinompdf(neighb0, n - 1,W_prior$bbinom_a_prior, W_prior$bbinom_b_prior, W_prior$min_neighbors, W_prior$max_neighbors) *
            (1 - curr.W_prior[ii, jj])
          # if (neighb0 == 0) {bbprior0 = 0}
          if (W_prior$symmetric_prior) {
            neighb1 <- sum((W1 + t(W1))[ii, ])
          } else {
            neighb1 <- sum(W1[ii, ])
          }
          # bbprior1 = bbinompdf(neighb1,n-1,bbinom_a_prior,bbinom_b_prior) * curr.W_prior[ii,jj]
          bbprior1 <- bbinompdf(neighb1, n - 1, W_prior$bbinom_a_prior, W_prior$bbinom_b_prior, W_prior$min_neighbors, W_prior$max_neighbors) *
            curr.W_prior[ii, jj]
          bbprior_ <- bbprior1 / (bbprior1 + bbprior0)
        } else {
          bbprior_ <- curr.W_prior[ii, jj]
        }

        err1 <- sum((A1[ch_elmnt, ] %*% tY - curr.txb[ch_elmnt, ])^2)
        err0 <- sum((A0[ch_elmnt, ] %*% tY - curr.txb[ch_elmnt, ])^2)
        adj <- min(err0, err1)
        err1 <- err1 - adj
        err0 <- err0 - adj

        # change 23.02.2022
        #p1 =   bbprior_ * exp(logdet1*tt) * dnorm(err1,0,sqrt(curr.sigma))
        #p0 = (1- bbprior_) * exp(logdet0*tt) * dnorm(err0,0,sqrt(curr.sigma))
        p1 <- bbprior_ * exp(logdet1 * tt) * exp(-err1 / (curr.sigma))
        p0 <- (1 - bbprior_) * exp(logdet0 * tt) * exp(-err0 / (curr.sigma))

        prob.delta <- p1 / (p1 + p0)
        if (is.na(prob.delta)) {
          prob.delta <- 0
        }
        rnd_draw <- stats::runif(1)
        if (rnd_draw <= prob.delta) {
          curr.W[ii, jj] <- 1
          if (!was1) {
            curr.logdet <- logdet1
            curr.A <- A1
            curr.AI <- res1$AI
            curr.w <- w1
          }
        } else {
          curr.W[ii, jj] <- 0
          if (was1) {
            curr.logdet <- logdet0
            curr.A <- A0
            curr.AI <- res0$AI
            curr.w <- w0
          }
        }
      }
    }
  }
  if (W_prior$row_standardized_prior) {
    if (W_prior$symmetric_prior) {
      curr.w <- (curr.W + t(curr.W)) / rowSums(curr.W + t(curr.W))
    } else {
      curr.w <- curr.W / rowSums(curr.W)
    }
    if (any(is.na(curr.w))) {
      curr.w[is.na(curr.w)] <- 0
    }
  } else {
    if (W_prior$symmetric_prior) {
      curr.w <- curr.W + t(curr.W)
    } else {
      curr.w <- curr.W
    }
  }

  wdraws$curr.W = curr.W
  wdraws$curr.w = curr.w
  wdraws$curr.A = curr.A
  wdraws$curr.AI = curr.AI
  wdraws$curr.logdet = curr.logdet
  return(wdraws)
}
